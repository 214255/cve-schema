const fs = require('fs');
const readline = require('readline');

function cvePath(value) {
  var realId = value.match(/(CVE-(\d{4})-(\d{1,12})(\d{3}))/);
  if (realId) {
    var id = realId[1];
    var year = realId[2];
    var bucket = realId[3];
    return (year + '/' + bucket + 'xxx/' + id + '.json')
  }
}

const validateCve = require('./dist/cve5validator.js')
var errorStat = {};
var errorCount = {};
var yStat = {};
var invalid = 0;
var total = 0;
var ignore = { '': 1, '/cveMetadata/state': 1 }
function validate(line) {
  if (line) {
    var parts = line.match(/(CVE-(\d+)-\d+)/);
    var year = "unknown";
    var id = "unknown";
    if (parts) {
      year = parts[2];
      id = parts[1];
    }
    try {
      if (!fs.lstatSync(line).isDirectory()) {
        var cveFile = fs.readFileSync(line);
        var cve = JSON.parse(cveFile);
        var assigner = "default";
        try {
          assigner = cve.containers.cna.x_legacyV4Record.CVE_data_meta.ASSIGNER;
        } catch (e) {
        }
        total++;
        var valid = validateCve(cve);
        if (!valid) {
          yStat[year] ? yStat[year]++ : (yStat[year] = 1);
          invalid++;
          validateCve.errors.forEach(err => {
            var path = err.instancePath.replace(/\/\d+\/?/g, "/")
            if (!ignore[path]) {
              if (!errorStat[path]) {
                errorStat[path] = {}
                errorCount[path] = 0
              }
              if (!errorStat[path][err.keyword]) {
                errorStat[path][err.keyword] = {}
              }
              if (!errorStat[path][err.keyword][assigner]) {
                errorStat[path][err.keyword][assigner] = []
              }
              errorStat[path][err.keyword][assigner].push(id);
              errorCount[path]++;
            }
          });
        }
      }
    } catch (e) {
      console.error(e.message);
    }
  }
}
/* Example error
  {
    instancePath: '/cveMetadata/state',
    schemaPath: '#/properties/state/enum',
    keyword: 'enum',
    params: { allowedValues: [Array] },
    message: 'must be equal to one of the allowed values'
  },
  */
var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
});

function report() {
  console.log(`
  <html><head><style>
  body{
    font-family:Roboto Mono,sans-serif;
  }
  .grid {
    display: inline-grid;
    gap: 5px;
    grid-template: repeat(1, 1fr) / repeat(8, 1fr);
  }
  </style></head>
  <body><h2>
  Validation errors in ${invalid} out of ${total} upconverted CVEs.
  </h2>
  `)
  for (const y in yStat) {
    console.log(`<li>year ${y} - ${yStat[y]}</li>`)
  }
  Object.keys(errorStat).sort().forEach(x => {
    console.log(`<h3>${x} [${errorCount[x]}]</h3>`)
    for (const k in errorStat[x]) {
      var alist = errorStat[x][k];
      for (const a in alist) {
        console.log(`<details><summary>${k} error [${alist[a].length}] - ${a}:</summary><blockquote class="grid">`)
        for (const c of alist[a]) {
          var p = cvePath(c)
          console.log(` <a href="https://github.com/CVEProject/cve-schema/tree/master/schema/v5.0/support/v5ReviewSet/${p}">${c}</a>`)
        }
        console.log('</blockquote></details>')
      }
    }
  });
}

rl.on('line', validate)
rl.on('close', report)